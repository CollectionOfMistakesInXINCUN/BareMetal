/****************************************************************************/
/**
*
* @file ps_init.c
*
* This file is automatically generated
*
*****************************************************************************/

#include "ps_init.h"

unsigned long ps_mio_init_data[] = {
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),

    // MIO_PIN_0
    // .. SIGNAL   = gpio[0]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x700, 0x0000FFFFU, 0x00005600U),
    // MIO_PIN_1
    // .. SIGNAL   = qspi0_cs
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x704, 0x0000FFFFU, 0x00005702U),
    // MIO_PIN_2
    // .. SIGNAL   = qspi0_io[0]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x708, 0x0000FFFFU, 0x00004702U),
    // MIO_PIN_3
    // .. SIGNAL   = qspi0_io[1]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x70C, 0x0000FFFFU, 0x00004702U),
    // MIO_PIN_4
    // .. SIGNAL   = qspi0_io[2]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x710, 0x0000FFFFU, 0x00004702U),
    // MIO_PIN_5
    // .. SIGNAL   = qspi0_io[3]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x714, 0x0000FFFFU, 0x00004702U),
    // MIO_PIN_6
    // .. SIGNAL   = qspi0_sclk
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x718, 0x0000FFFFU, 0x00004702U),
    // MIO_PIN_7
    // .. SIGNAL   = gpio[7]
    // .. DIR      = out
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x71C, 0x0000FFFFU, 0x00004600U),
    // MIO_PIN_8
    // .. SIGNAL   = gpio[8]
    // .. DIR      = out
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = disabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x720, 0x0000FFFFU, 0x00004600U),
    // MIO_PIN_9
    // .. SIGNAL   = gpio[9]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x724, 0x0000FFFFU, 0x00005600U),
    // MIO_PIN_10
    // .. SIGNAL   = spi1_mosi
    // .. DIR      = inout
    // .. L3-0 SEL = B'1010000
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x728, 0x0000FFFFU, 0x000057a0U),
    // MIO_PIN_11
    // .. SIGNAL   = spi1_miso
    // .. DIR      = inout
    // .. L3-0 SEL = B'1010000
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x72C, 0x0000FFFFU, 0x000057a0U),
    // MIO_PIN_12
    // .. SIGNAL   = spi1_ck
    // .. DIR      = inout
    // .. L3-0 SEL = B'1010000
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x730, 0x0000FFFFU, 0x000057a0U),
    // MIO_PIN_13
    // .. SIGNAL   = spi1_ss0
    // .. DIR      = inout
    // .. L3-0 SEL = B'1010000
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x734, 0x0000FFFFU, 0x000057a0U),
    // MIO_PIN_14
    // .. SIGNAL   = can0_rx
    // .. DIR      = in
    // .. L3-0 SEL = B'0010000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x738, 0x0000FFFFU, 0x00005621U),
    // MIO_PIN_15
    // .. SIGNAL   = can0_tx
    // .. DIR      = out
    // .. L3-0 SEL = B'0010000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 3.3V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x73C, 0x0000FFFFU, 0x00005620U),
    // MIO_PIN_16
    // .. SIGNAL   = gmac0_rgmii_tx_clk
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x740, 0x0000FFFFU, 0x00005302U),
    // MIO_PIN_17
    // .. SIGNAL   = gmac0_rgmii_txd[0]
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x744, 0x0000FFFFU, 0x00005302U),
    // MIO_PIN_18
    // .. SIGNAL   = gmac0_rgmii_txd[1]
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x748, 0x0000FFFFU, 0x00005302U),
    // MIO_PIN_19
    // .. SIGNAL   = gmac0_rgmii_txd[2]
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x74C, 0x0000FFFFU, 0x00005302U),
    // MIO_PIN_20
    // .. SIGNAL   = gmac0_rgmii_txd[3]
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x750, 0x0000FFFFU, 0x00005302U),
    // MIO_PIN_21
    // .. SIGNAL   = gmac0_rgmii_tx_ctl
    // .. DIR      = out
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x754, 0x0000FFFFU, 0x00005302U),
    // MIO_PIN_22
    // .. SIGNAL   = gmac0_rgmii_rx_clk
    // .. DIR      = in
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x758, 0x0000FFFFU, 0x00005303U),
    // MIO_PIN_23
    // .. SIGNAL   = gmac0_rgmii_rxd[0]
    // .. DIR      = in
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x75C, 0x0000FFFFU, 0x00005303U),
    // MIO_PIN_24
    // .. SIGNAL   = gmac0_rgmii_rxd[1]
    // .. DIR      = in
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x760, 0x0000FFFFU, 0x00005303U),
    // MIO_PIN_25
    // .. SIGNAL   = gmac0_rgmii_rxd[2]
    // .. DIR      = in
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x764, 0x0000FFFFU, 0x00005303U),
    // MIO_PIN_26
    // .. SIGNAL   = gmac0_rgmii_rxd[3]
    // .. DIR      = in
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x768, 0x0000FFFFU, 0x00005303U),
    // MIO_PIN_27
    // .. SIGNAL   = gmac0_rgmii_rx_ctl
    // .. DIR      = in
    // .. L3-0 SEL = B'0000001
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x76C, 0x0000FFFFU, 0x00005303U),
    // MIO_PIN_28
    // .. SIGNAL   = usb0_ulpi_data[4]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x770, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_29
    // .. SIGNAL   = usb0_ulpi_dir
    // .. DIR      = in
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x774, 0x0000FFFFU, 0x00005305U),
    // MIO_PIN_30
    // .. SIGNAL   = usb0_ulpi_stp
    // .. DIR      = out
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x778, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_31
    // .. SIGNAL   = usb0_ulpi_nxt
    // .. DIR      = in
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x77C, 0x0000FFFFU, 0x00005305U),
    // MIO_PIN_32
    // .. SIGNAL   = usb0_ulpi_data[0]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x780, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_33
    // .. SIGNAL   = usb0_ulpi_data[1]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x784, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_34
    // .. SIGNAL   = usb0_ulpi_data[2]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x788, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_35
    // .. SIGNAL   = usb0_ulpi_data[3]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x78C, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_36
    // .. SIGNAL   = usb0_ulpi_ck
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x790, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_37
    // .. SIGNAL   = usb0_ulpi_data[5]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x794, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_38
    // .. SIGNAL   = usb0_ulpi_data[6]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x798, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_39
    // .. SIGNAL   = usb0_ulpi_data[7]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000010
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x79C, 0x0000FFFFU, 0x00005304U),
    // MIO_PIN_40
    // .. SIGNAL   = sdio0_clk
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7A0, 0x0000FFFFU, 0x00005280U),
    // MIO_PIN_41
    // .. SIGNAL   = sdio0_cmd
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7A4, 0x0000FFFFU, 0x00005280U),
    // MIO_PIN_42
    // .. SIGNAL   = sdio0_io[0]
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7A8, 0x0000FFFFU, 0x00005280U),
    // MIO_PIN_43
    // .. SIGNAL   = sdio0_io[1]
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7AC, 0x0000FFFFU, 0x00005280U),
    // MIO_PIN_44
    // .. SIGNAL   = sdio0_io[2]
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7B0, 0x0000FFFFU, 0x00005280U),
    // MIO_PIN_45
    // .. SIGNAL   = sdio0_io[3]
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7B4, 0x0000FFFFU, 0x00005280U),
    // MIO_PIN_46
    // .. SIGNAL   = gpio[46]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7B8, 0x0000FFFFU, 0x00005200U),
    // MIO_PIN_47
    // .. SIGNAL   = gpio[47]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7BC, 0x0000FFFFU, 0x00005200U),
    // MIO_PIN_48
    // .. SIGNAL   = gpio[48]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7C0, 0x0000FFFFU, 0x00005200U),
    // MIO_PIN_49
    // .. SIGNAL   = gpio[49]
    // .. DIR      = inout
    // .. L3-0 SEL = B'0000000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7C4, 0x0000FFFFU, 0x00005200U),
    // MIO_PIN_50
    // .. SIGNAL   = uart0_rx
    // .. DIR      = in
    // .. L3-0 SEL = B'1110000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7C8, 0x0000FFFFU, 0x000052e1U),
    // MIO_PIN_51
    // .. SIGNAL   = uart0_tx
    // .. DIR      = out
    // .. L3-0 SEL = B'1110000
    // .. SPEED    = slow
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7CC, 0x0000FFFFU, 0x000052e0U),
    // MIO_PIN_52
    // .. SIGNAL   = mdio0_ck
    // .. DIR      = out
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7D0, 0x0000FFFFU, 0x00005380U),
    // MIO_PIN_53
    // .. SIGNAL   = mdio0_data
    // .. DIR      = inout
    // .. L3-0 SEL = B'1000000
    // .. SPEED    = fast
    // .. IO TYPE  = LVCMOS 1.8V
    // .. PULLUP   = enabled
    // .. DRIVE STRENTH   = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x7D4, 0x0000FFFFU, 0x00005380U),

    // SDIO0_WP_SEL = 55
    // SDIO0_CD_SEL = 56
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x830, 0x003F003FU, 0x00380037U),
    // SDIO1_WP_SEL = 57
    // SDIO1_CD_SEL = 58
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x834, 0x003F003FU, 0x003a0039U),
    // GMAC_CTRL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x414, 0x00000007U, 0x00000001U),

    //COPY VMODE TO VMODE_MIO
    EMIT_MASKCOPY(SLCR_REG_BASE + 0x404, SLCR_REG_BASE + 0x404, 0x00000060U, 0x00000180U),

    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),

    EMIT_EXIT(),
};

unsigned long ps_pll_init_data[] = {
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),

    // CPU_PLL_BYPASS_FORCE = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x100, 0x00000008U, 0x00000008U),
    // CPU_PLL_RESET = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x100, 0x00000001U, 0x00000001U),
    // CPU_PLL_FDIV = 30
    // [22:16]
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x100, 0x007f0000U, 0x001e0000U),
    // CPU_PLL_CLKOUT0_DIVISOR = 0x1
    // [6:0]
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x104, 0x0000007fU, 0x00000001U),
    // CPU_PLL_CFG
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x174, 0x000000f0U, 0x00000080U),
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x174, 0x00000f00U, 0x00000c00U),
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x174, 0x003ff000U, 0x00177000U),
    // ENABLE CPU PLL LATCH
    EMIT_WRITE(SLCR_REG_BASE + 0x180, 0x00000001U),
    // CPU_PLL_RESET = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x100, 0x00000001U, 0x00000000U),
    // CHECK CPU PLL STATUS
    EMIT_MASKPOLL(SLCR_REG_BASE + 0x170, 0x00000001U),
    // CPU_PLL_BYPASS_FORCE = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x100, 0x00000008U, 0x00000000U),
    // DDR_PLL_BYPASS_FORCE = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x130, 0x00000008U, 0x00000008U),
    // DDR_PLL_RESET = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x130, 0x00000001U, 0x00000001U),
    // DDR_PLL_FDIV = 45
    // [22:16]
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x130, 0x007f0000U, 0x002d0000U),
    // DDR_PLL_CLKOUT0_DIVISOR = 0x1
    // [6:0]
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x134, 0x0000007fU, 0x00000001U),
    // DDR PLL CFG
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x178, 0x000000f0U, 0x00000010U),
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x178, 0x00000f00U, 0x00000100U),
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x178, 0x003ff000U, 0x00177000U),
    // ENABLE DDR PLL LATCH
    EMIT_WRITE(SLCR_REG_BASE + 0x184, 0x00000001U),
    // DDR_PLL_RESET = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x130, 0x00000001U, 0x00000000U),
    // CHECK DDR PLL STATUS
    EMIT_MASKPOLL(SLCR_REG_BASE + 0x170, 0x00000002U),
    // DDR_PLL_BYPASS_FORCE = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x130, 0x00000008U, 0x00000000U),
    // IO_PLL_BYPASS_FORCE = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x150, 0x00000008U, 0x00000008U),
    // IO_PLL_RESET = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x150, 0x00000001U, 0x00000001U),
    // IO_PLL_FDIV = 30
    // [22:16]
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x150, 0x007f0000U, 0x001e0000U),
    // IO_PLL_CLKOUT0_DIVISOR = 0x1
    // [6:0]
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x154, 0x0000007fU, 0x00000001U),
    // IO PLL CFG
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x17C, 0x000000f0U, 0x00000080U),
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x17C, 0x00000f00U, 0x00000c00U),
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x17C, 0x003ff000U, 0x00177000U),
    // ENABLE IO PLL LATCH
    EMIT_WRITE(SLCR_REG_BASE + 0x188, 0x00000001U),
    // IO_PLL_RESET = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x150, 0x00000001U, 0x00000000U),
    // CHECK IO PLL STATUS
    EMIT_MASKPOLL(SLCR_REG_BASE + 0x170, 0x00000004U),
    // IO_PLL_BYPASS_FORCE = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x150, 0x00000008U, 0x00000000U),

    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),

    EMIT_EXIT(),
};

unsigned long ps_clock_init_data[] = {
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),

    // CLK_621_TRUE = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x20C, 0x00000001U, 0x00000000U),
    // DDR CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x218, 0x00000001U, 0x00000001U),
    // DDR APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x218, 0x00000002U, 0x00000002U),
    // DDR AXI CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x218, 0x00000004U, 0x00000004U),
    // DDR SRC SEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x218, 0x00000018U, 0x00000000U),
    // DDR DIVISOR = 4
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x218, 0x000007e0U, 0x00000080U),
    // ENET0 TX CLK SOURCE = IO PLL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x000001c0U, 0x00000000U),
    // ENET0 RX CLK SOURCE = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x00000020U, 0x00000000U),
    // ENET0 TX CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x00000001U, 0x00000001U),
    // ENET0 RX CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x00000002U, 0x00000002U),
    // ENET0 AXI CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x00000008U, 0x00000008U),
    // ENET0 AHB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x00000010U, 0x00000010U),
    // ENET0 TX DIVISOR1 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x00007e00U, 0x00000200U),
    // ENET0 TX DIVISOR0 = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x001f8000U, 0x00040000U),
    // ENET0 TS DIVISOR0 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x07e00000U, 0x00200000U),
    // ENET0 TS CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x268, 0x08000000U, 0x08000000U),
    // ENET1 TX CLK SOURCE = IO PLL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x000001c0U, 0x00000000U),
    // ENET1 RX CLK SOURCE = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x00000020U, 0x00000000U),
    // ENET1 TX CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x00000001U, 0x00000000U),
    // ENET1 RX CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x00000002U, 0x00000000U),
    // ENET1 AXI CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x00000008U, 0x00000000U),
    // ENET1 AHB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x00000010U, 0x00000000U),
    // ENET1 TX DIVISOR1 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x00007e00U, 0x00000200U),
    // ENET1 TX DIVISOR0 = 8
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x001f8000U, 0x00178000U),
    // ENET1 TS DIVISOR0 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x07e00000U, 0x00200000U),
    // ENET1 TS CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x26C, 0x08000000U, 0x00000000U),
    // QSPI CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x284, 0x00000001U, 0x00000001U),
    // QSPI APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x284, 0x00000002U, 0x00000002U),
    // QSPI AHB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x284, 0x00000004U, 0x00000004U),
    // QSPI CLK SOURCE = IO PLL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x284, 0x00000030U, 0x00000000U),
    // QSPI DIVISOR = 5
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x284, 0x00000fc0U, 0x00000140U),
    // SDIO0 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x28C, 0x00000001U, 0x00000001U),
    // SDIO0 AHB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x28C, 0x00000004U, 0x00000004U),
    // SDIO1 CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x28C, 0x00000002U, 0x00000000U),
    // SDIO1 AHB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x28C, 0x00000008U, 0x00000000U),
    // SDIO CLK SOURCE = IO PLL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x28C, 0x00000030U, 0x00000000U),
    // SDIO DIVISOR = 10
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x28C, 0x00000fc0U, 0x00000280U),
    // UART0 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x294, 0x00000001U, 0x00000001U),
    // UART0 APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x294, 0x00000004U, 0x00000004U),
    // UART1 CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x294, 0x00000002U, 0x00000000U),
    // UART1 APB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x294, 0x00000008U, 0x00000000U),
    // UART CLK SOURCE = IO PLL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x294, 0x00000030U, 0x00000000U),
    // UART DIVISOR = 5
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x294, 0x00000fc0U, 0x00000140U),
    // SPI0 CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x29C, 0x00000001U, 0x00000000U),
    // SPI0 APB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x29C, 0x00000004U, 0x00000000U),
    // SPI1 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x29C, 0x00000002U, 0x00000002U),
    // SPI1 APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x29C, 0x00000008U, 0x00000008U),
    // SPI CLK SOURCE = IO PLL
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x29C, 0x00000030U, 0x00000000U),
    // SPI DIVISOR = 5
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x29C, 0x00000fc0U, 0x00000140U),
    // CAN0 APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x304, 0x00000001U, 0x00000001U),
    // CAN1 APB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x304, 0x00000002U, 0x00000000U),
    // GPIO APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x30C, 0x00000001U, 0x00000001U),
    // I2C0 APB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x314, 0x00000001U, 0x00000000U),
    // I2C1 APB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x314, 0x00000002U, 0x00000000U),
    // USB0 AHB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00000001U, 0x00000001U),
    // USB0 PHY CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00000004U, 0x00000004U),
    // USB0 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00001000U, 0x00001000U),
    // USB0 SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00000030U, 0x00000000U),
    // USB0 DIVISOR = 5
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00000fc0U, 0x00000140U),
    // USB1 AHB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00000002U, 0x00000000U),
    // USB1 PHY CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00000008U, 0x00000000U),
    // USB1 CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00200000U, 0x00000000U),
    // USB1 SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x00006000U, 0x00000000U),
    // USB1 DIVISOR = 47
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x31C, 0x001f8000U, 0x00178000U),
    // WDT CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x32C, 0x00000008U, 0x00000000U),
    // WDT APB CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x32C, 0x00000004U, 0x00000000U),
    // WDT CLK SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x32C, 0x00000003U, 0x00000000U),
    // TTC0 CLK0 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00004000U, 0x00004000U),
    // TTC0 CLK1 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00008000U, 0x00008000U),
    // TTC0 CLK2 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00010000U, 0x00010000U),
    // TTC0 APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00001000U, 0x00001000U),
    // TTC1 CLK0 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00020000U, 0x00020000U),
    // TTC1 CLK1 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00040000U, 0x00040000U),
    // TTC1 CLK2 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00080000U, 0x00080000U),
    // TTC1 APB CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00002000U, 0x00002000U),
    // TTC0 CLK0 SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00000003U, 0x00000000U),
    // TTC0 CLK1 SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x0000000cU, 0x00000000U),
    // TTC0 CLK2 SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00000030U, 0x00000000U),
    // TTC1 CLK0 SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x000000c0U, 0x00000000U),
    // TTC1 CLK1 SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00000300U, 0x00000000U),
    // TTC1 CLK2 SOURCE = CLK_APB
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x334, 0x00000c00U, 0x00000000U),
    // APU SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x350, 0x00000007U, 0x00000000U),
    // APU DIVISOR = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x350, 0x00003f00U, 0x00000100U),
    // TOPSW_SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x354, 0x00000007U, 0x00000000U),
    // TOPSW DIVISOR0 = 3
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x354, 0x00003f00U, 0x00000300U),
    // GPU_SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x358, 0x00000007U, 0x00000000U),
    // GPU DIVISOR = 3
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x358, 0x00003f00U, 0x00000300U),
    // TRACE SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x35C, 0x00000007U, 0x00000000U),
    // TRACE DIVISOR = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x35C, 0x00003f00U, 0x00000100U),
    // TRACE CLKACT = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x35C, 0x01000000U, 0x00000000U),
    // CSSYS SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x360, 0x00000007U, 0x00000000U),
    // CSSYS DIVISOR = 4
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x360, 0x00003f00U, 0x00000400U),
    // CSSYS CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x360, 0x01000000U, 0x01000000U),
    // TS SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x364, 0x00000007U, 0x00000000U),
    // TS DIVISOR = 4
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x364, 0x00003f00U, 0x00000400U),
    // TS CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x364, 0x01000000U, 0x01000000U),
    // CSU SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x368, 0x00000007U, 0x00000000U),
    // CSU DIVISOR = 10
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x368, 0x00003f00U, 0x00000a00U),
    // CSU CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x368, 0x01000000U, 0x01000000U),
    // DMA SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x36C, 0x00000007U, 0x00000000U),
    // DMA DIVISOR = 3
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x36C, 0x00003f00U, 0x00000300U),
    // DMA CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x36C, 0x01000000U, 0x01000000U),
    // FPGA0 SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x370, 0x00000007U, 0x00000000U),
    // FPGA0 DIVISOR0 = 30
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x370, 0x00003f00U, 0x00001e00U),
    // FCLK0 DIVISOR1 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x370, 0x000fc000U, 0x00004000U),
    // FCLK0 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x370, 0x01000000U, 0x01000000U),
    // FPGA1 SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x374, 0x00000007U, 0x00000000U),
    // FPGA1 DIVISOR0 = 47
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x374, 0x00003f00U, 0x00002f00U),
    // FPGA1 DIVISOR1 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x374, 0x000fc000U, 0x00004000U),
    // FPGA1 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x374, 0x01000000U, 0x00000000U),
    // FPGA2 SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x378, 0x00000007U, 0x00000000U),
    // FPGA2 DIVISOR0 = 47
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x378, 0x00003f00U, 0x00002f00U),
    // FPGA2 DIVISOR1 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x378, 0x000fc000U, 0x00004000U),
    // FPGA2 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x378, 0x01000000U, 0x00000000U),
    // FPGA3 SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x37C, 0x00000007U, 0x00000000U),
    // FPGA3 DIVISOR0 = 47
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x37C, 0x00003f00U, 0x00002f00U),
    // FPGA3 DIVISOR1 = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x37C, 0x000fc000U, 0x00004000U),
    // FPGA3 CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x37C, 0x01000000U, 0x00000000U),
    // VPU SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x38C, 0x00000007U, 0x00000000U),
    // VPU DIVISOR0 = 2
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x38C, 0x00003f00U, 0x00000200U),
    // VPU CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x38C, 0x01000000U, 0x01000000U),
    // APU GTC SRCSEL = 0
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x390, 0x00000007U, 0x00000000U),
    // APU GTC DIVISOR0 = 10
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x390, 0x00003f00U, 0x00000a00U),
    // APU GTC CLKACT = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x390, 0x01000000U, 0x01000000U),

    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),

    EMIT_EXIT(),
};

unsigned long ps_ddr_init_data[] = {
    // DDR enable
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),
    // DDR_CLK_CTRL = 1
    EMIT_MASKWRITE(SLCR_REG_BASE + 0x218, 0x00000001U, 0x00000001U),
    // DDR_RST_CTRL = 0111
    EMIT_WRITE(SLCR_REG_BASE + 0x21C, 0x00000007U),
    // DDR_RST_CTRL = 0101
    EMIT_WRITE(SLCR_REG_BASE + 0x21C, 0x00000005U),
    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),
    // DFI Timing Set
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x1A4, 0x0008000CU),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x190, 0x007f0000U, 0x00040000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x190, 0x00003f00U, 0x00000100U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x190, 0x0000003fU, 0x00000003U),
    //  Dessert dfi_init_complete_en
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x1B0, 0x00000000U),
    // Set SDRAM burst length, data_bus_length, mem type
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x000, 0x00040001U),
    // Set SDRAM SDRAM Initialization skip, post_cke, pre_cke
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x0D0, 0x40020032U),
    // Set dram_rstn
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x0D4, 0x00900000U),
    // Write MR0 & MR1
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0DC, 0x000000ffU, 0x000000c6U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0DC, 0x00000200U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0DC, 0x00030000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0DC, 0x00040000U, 0x00040000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0DC, 0x00700000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0DC, 0x0e000000U, 0x0e000000U),
    // Write MR2 & MR3
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0E0, 0x00380000U, 0x00180000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0E0, 0x00800000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0E0, 0x00070000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0E0, 0x00400000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x0E0, 0x06000000U, 0x00000000U),
    // Set tRfc
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x064, 0x000003ffU, 0x00000078U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x064, 0x0fff0000U, 0x00620000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x064, 0x80000000U, 0x00000000U),
    // Set DRAMTMG0
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x100, 0x0000003fU, 0x0000000eU),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x100, 0x00007f00U, 0x00001a00U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x100, 0x003f0000U, 0x00100000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x100, 0x7f000000U, 0x0c000000U),
    // Set DRAMTMG1
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x104, 0x0000007fU, 0x00000014U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x104, 0x00003f00U, 0x00000300U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x104, 0x001f0000U, 0x00080000U),
    // Set DRAMTMG2
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x108, 0x0000003fU, 0x00000009U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x108, 0x00003f00U, 0x00000500U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x108, 0x003f0000U, 0x00060000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x108, 0x3f000000U, 0x04000000U),
    // Set DRAMTMG4
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x110, 0x0000001fU, 0x00000006U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x110, 0x00000f00U, 0x00000200U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x110, 0x000f0000U, 0x00020000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x110, 0x1f000000U, 0x05000000U),
    // Set DRAMTMG5
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x114, 0x0000001fU, 0x00000003U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x114, 0x00003f00U, 0x00000400U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x114, 0x000f0000U, 0x00040000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x114, 0x0f000000U, 0x04000000U),
    // Set DRAMTMG8
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x120, 0x0000007fU, 0x00000005U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x120, 0x00007f00U, 0x00000900U),
    // Set Address Map ,according to memory depth
    //  Bank 2-0
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x204, 0x0000003fU, 0x00000017U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x204, 0x00003f00U, 0x00001700U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x204, 0x003f0000U, 0x00170000U),
    //  Column 5-2
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x208, 0x000f0000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x208, 0x0f000000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x208, 0x00001f00U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x208, 0x0000000fU, 0x00000000U),
    //  Column 9-6
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x20C, 0x0000001fU, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x20C, 0x00001f00U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x20C, 0x001f0000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x20C, 0x1f000000U, 0x00000000U),
    //  Column 11-10
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x210, 0x00001F1FU),
    //  Row 11-0
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x214, 0x0000000fU, 0x00000004U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x214, 0x00000f00U, 0x00000400U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x214, 0x000f0000U, 0x00040000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x214, 0x0f000000U, 0x04000000U),
    //  Row 16-12
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x218, 0x0000000fU, 0x00000004U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x218, 0x00000f00U, 0x00000400U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x218, 0x000f0000U, 0x00040000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x218, 0x0f000000U, 0x0f000000U),

    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),
    // DDR_RST_CTRL = 0
    EMIT_WRITE(SLCR_REG_BASE + 0x21C, 0x00000000U),
    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),
    // DDRMD
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x100, 0x00000007U, 0x00000003U),
    // DX2GCR0, DXEN
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x900, 0x00000001U, 0x00000001U),
    // DX3GCR0, DXEN
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0xA00, 0x00000001U, 0x00000001U),
    // PLLCR, FRQSEL, PLL reference clock range 225MHz-490MHz
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x080, 0x00180000U, 0x00080000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x680, 0x00000700U, 0x00000500U),
    // Set icpc ,dfi_intial_complete status, 
    //     indicate PUB complete Dram Initial
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x010, 0x07D81E01U),
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x014, 0x02004020U),
    // Trigger PHY initialization Register
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x004, 0x00000073U),
    EMIT_MASKPOLL(DDR_PUB_REG_BASE + 0x034, 0x0000000fU),
    // Set SWCTL.sw_done to 0
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x320, 0x00000000U),
    // Set dfimisc.dfi_init_complete_en to 1
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x1B0, 0x00000001U),
    // Set SWCTL.sw_done to 1
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x320, 0x00000001U),
    EMIT_MASKPOLL(DDR_UMC_REG_BASE + 0x324, 0x00000001U),
    // MR0 Register configure
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x180, 0x00000003U, 0x00000000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x180, 0x00000004U, 0x00000004U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x180, 0x00000070U, 0x00000000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x180, 0x00000e00U, 0x00000e00U),
    // MR1 Register configure
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x184, 0x000000ffU, 0x000000c6U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x184, 0x00000200U, 0x00000000U),
    // MR2 Register configure
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x188, 0x00000038U, 0x00000018U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x188, 0x00000080U, 0x00000000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x188, 0x00000007U, 0x00000000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x188, 0x00000040U, 0x00000000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x188, 0x00000600U, 0x00000000U),
    // DRAM Timing Resigter
    //  DTPR0
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x110, 0x0000000fU, 0x00000006U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x110, 0x00007f00U, 0x00000b00U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x110, 0x007f0000U, 0x001c0000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x110, 0x3f000000U, 0x07000000U),
    //  DTPR1
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x114, 0x00000700U, 0x00000c00U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x114, 0x00ff0000U, 0x00200000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x114, 0x0000001fU, 0x00000005U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x114, 0x3f000000U, 0x28000000U),
    //  DTPR2
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x118, 0x000003ffU, 0x000000f8U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x118, 0x000f0000U, 0x00060000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x118, 0x01000000U, 0x00000000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x118, 0x10000000U, 0x00000000U),
    //  DTPR3
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x11C, 0x00000007U, 0x00000001U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x11C, 0x00000700U, 0x00000100U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x11C, 0xffff0000U, 0x02000000U),
    //  DTPR4
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x120, 0x0000001fU, 0x00000006U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x120, 0x00000f00U, 0x00000600U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x120, 0x03ff0000U, 0x012c0000U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x120, 0x30000000U, 0x00000000U),
    //  DTPR5
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x124, 0x0000001fU, 0x00000006U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x124, 0x00007f00U, 0x00000b00U),
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x124, 0x00ff0000U, 0x00270000U),
    // Training parameter Setting
    //  DRAM TYPE
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x100, 0x00000007U, 0x00000003U),
    //  Training parameter
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x200, 0x8000B0C7U),
    //  DCU Timing
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x314, 0x000000FFU),
    //  Set refresh time
    EMIT_MASKWRITE(DDR_PUB_REG_BASE + 0x018, 0x0003ffffU, 0x0000db60U),
    //  Reset value
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x098, 0x00010000U),
    //  Reset value
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x52C, 0x0FC00072U),
    // Configure pub pir register
    EMIT_WRITE(DDR_PUB_REG_BASE + 0x004, 0x00000F81U),
    EMIT_MASKPOLL(DDR_PUB_REG_BASE + 0x034, 0x000000ffU),
    // Enable umctl2 axi_port4
    EMIT_WRITE(DDR_UMC_REG_BASE + 0x320, 0x00000000U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x490, 0x00000001U, 0x00000001U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x540, 0x00000001U, 0x00000001U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x5F0, 0x00000001U, 0x00000001U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x6A0, 0x00000001U, 0x00000001U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x750, 0x00000001U, 0x00000001U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x240, 0x0000007cU, 0x00000010U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x240, 0x00000f00U, 0x00000600U),
    EMIT_MASKWRITE(DDR_UMC_REG_BASE + 0x240, 0x0f000000U, 0x06000000U),
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),
    // ECC = 0
    EMIT_WRITE(SLCR_REG_BASE + 0x490, 0x00000000U),
    EMIT_EXIT(),
};

unsigned long ps_peripherals_init_data[] = {
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),


    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),



    EMIT_EXIT(),
};

unsigned long ps_post_init_data[] = {
    // UNLOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x008, 0xDF0D767BU),


    // LOCK_KEY = 0XDF0D767B
    EMIT_WRITE(SLCR_REG_BASE + 0x004, 0xDF0D767BU),

    EMIT_EXIT(),
};

unsigned long ps_debug_init_data[] = {
    EMIT_EXIT(),
};

unsigned long ps_post_config_init_data[] = {
    EMIT_EXIT(),
};

#define PS_MASK_POLL_TIME 100000000

char* getPSMessageInfo(unsigned key) {
  char* err_msg = "";
  switch (key) {
    case PS_INIT_SUCCESS:
      err_msg = "PS initialization successful"; break;
    case PS_INIT_CORRUPT:
      err_msg = "PS init Data Corrupted"; break;
    case PS_INIT_TIMEOUT:
      err_msg = "PS init mask poll timeout"; break;
    case PS_POLL_FAILED_DDR_INIT:
      err_msg = "Mask Poll failed for DDR Init"; break;
    case PS_POLL_FAILED_DMA:
      err_msg = "Mask Poll failed for PLL Init"; break;
    case PS_POLL_FAILED_PLL:
      err_msg = "Mask Poll failed for DMA done bit"; break;
    default:
      err_msg = "Undefined error status"; break;
  }
  return err_msg;
}


void mask_write (unsigned long add , unsigned long  mask, unsigned long val ) {
  volatile unsigned long *addr = (volatile unsigned long*) add;
  *addr = ( val & mask ) | ( *addr & ~mask);
}

int mask_poll(unsigned long add , unsigned long mask ) {
  volatile unsigned long *addr = (volatile unsigned long*) add;
  int i = 0;
  while (!(*addr & mask)) {
    if (i == PS_MASK_POLL_TIME) {
      return -1;
    }
    i++;
  }
  return 1;
}

unsigned long mask_read(unsigned long add , unsigned long mask) {
  volatile unsigned long *addr = (volatile unsigned long*) add;
  unsigned long val = (*addr & mask);
  return val;
}

void mask_copy(unsigned long addsrc , unsigned long addst, 
               unsigned long masksrc, unsigned long maskdst ) {
  volatile unsigned long *addrsrc = (volatile unsigned long*) addsrc;
  unsigned long val = (*addrsrc & masksrc);
  unsigned long masktmp = maskdst;
  int srclow = 0;
  while (!(masksrc & 1)) { masksrc >>= 1; ++srclow; };
  int dstlow = 0;
  while (!(masktmp & 1)) { masktmp >>= 1; ++dstlow; };
  val = (val >> srclow) << dstlow;
  volatile unsigned long *addrdst = (volatile unsigned long*) addst;
  *addrdst = ( val & maskdst ) | ( *addrdst & ~maskdst);
}

int ps_config(unsigned long * ps_config_init) {
  unsigned long *ptr = ps_config_init;
  unsigned long opcode; // current instruction ..
  unsigned long args[16]; // no opcode has so many args ...
  int numargs; // number of arguments of this instruction
  int  j; // general purpose index

  volatile unsigned int *addr;
  unsigned long  val,mask;
  volatile unsigned int *addrdst;
  unsigned long  maskdst,masktmp;

  int finish = -1 ; // loop while this is negative !
  int i = 0; // Timeout variable
  int srclow,dstlow;

  while (finish < 0) {
    numargs = ptr[0] & 0xF;
    opcode = ptr[0] >> 4;

    for( j = 0 ; j < numargs ; j ++ )
      args[j] = ptr[j+1];
    ptr += numargs + 1;

    switch ( opcode ) {
      case OPCODE_EXIT:
        finish = PS_INIT_SUCCESS;
        break;
      case OPCODE_CLEAR:
        addr = (unsigned int*) (unsigned long)args[0];
        *addr = 0;
        break;
      case OPCODE_WRITE:
        addr = (unsigned int*) (unsigned long)args[0];
        val = args[1];
        *addr = val;
        break;
      case OPCODE_MASKWRITE:
        addr = (unsigned int*) (unsigned long)args[0];
        mask = args[1];
        val = args[2];
        *addr = ( val & mask ) | ( *addr & ~mask);
        break;
      case OPCODE_MASKCOPY:
        addr = (unsigned int*) (unsigned long)args[0];
        addrdst = (unsigned int*) (unsigned long)args[1];
        mask = args[2];
        maskdst = args[3];
        masktmp = maskdst;
        val = (*addr & mask);
        srclow = 0;
        while (!(mask & 1)) { mask >>= 1; ++srclow; };
        dstlow = 0;
        while (!(masktmp & 1)) { masktmp >>= 1; ++dstlow; };
        val = (val >> srclow) << dstlow;
        *addrdst = ( val & maskdst ) | ( *addrdst & ~maskdst);
        break;
      case OPCODE_MASKPOLL:
        addr = (unsigned int*) (unsigned long)args[0];
        mask = args[1];
        i = 0;
        while ((*addr & mask) != mask) {
          if (i == PS_MASK_POLL_TIME) {
            finish = PS_INIT_TIMEOUT;
            break;
          }
          i++;
        }
        break;
      case OPCODE_MASKDELAY:
        break;
      default:
        finish = PS_INIT_CORRUPT;
        break;
    }
  }
  return finish;
}


int ps_post_config() {
  int ret = -1;
  ret = ps_config(ps_post_config_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;
  return PS_INIT_SUCCESS;
}

int ps_debug() {
  int ret = -1;
  ret = ps_config(ps_debug_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;
  return PS_INIT_SUCCESS;
}

int ps_init() {
  int ret;
  // MIO init
  ret = ps_config(ps_mio_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;

  // PLL init
  ret = ps_config(ps_pll_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;

  // Clock init
  ret = ps_config(ps_clock_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;

  // DDR init
  ret = ps_config(ps_ddr_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;

  // Peripherals init
  ret = ps_config(ps_peripherals_init_data);
  if (ret != PS_INIT_SUCCESS) return ret;

  return PS_INIT_SUCCESS;
}


